# 基本的なプログラミングルール

プログラミング言語やプロジェクトに依存しない、一般的な設計原則

---

## 設計原則

- 単一責任原則に従って公開 API が最小限になるようにする
- 例外を握りつぶさない
- コロケーションを意識する
- Single Source of Truth を意識する
- 可能な限り最低限の実装をする。将来的に使う可能性がある関数はそのときに実装する。必要であれば TODO コメントを残す

---

## 関数設計

- 関数には可能な限り返り値を記載する
- 引数は可能な限りオプショナルは避ける
  - 仕様として undefined が許容される場合は除く
- 副作用のない関数は、可能な限り純粋関数として実装し、別ファイルとする

---

## 関数型アプローチ (FP)

- 純粋関数を優先する
- 不変データ構造を使用する
- 副作用を分離する
- 型安全性を確保する

---

## ドメイン駆動設計 (DDD)

- 値オブジェクトとエンティティを区別する
- 集約で整合性を保証する
- リポジトリでデータアクセスを抽象化する
- 境界付けられたコンテキストを意識する

### ドメインサービスの扱い

- ドメインサービスは最終手段として扱うことが重要である
- 原則として、ビジネスロジックは値オブジェクトやエンティティにカプセル化する
- ドメインサービスの濫用は以下のリスクを生む
  - ドメインモデルの貧血化: エンティティや値オブジェクトがデータ保持だけになり、ビジネスルールがドメイン外へ漏れて整合性・変更容易性が落ちる状態
  - 振る舞いの漏れ出し
  - オブジェクト指向の原則違反
  - テストの複雑化
- ドメインサービスを使う場合は以下を満たすときのみとする
  - 複数の集約にまたがる処理で、どちらにも属さない場合
  - エンティティや値オブジェクトに配置すると不自然な場合
  - 外部サービスとの連携が必要であり、アプリケーションサービスも併せて検討すべき場合
- 実装前に以下を確認する
  1. この振る舞いは特定のエンティティや値オブジェクトに属せないか？
  2. 新しい値オブジェクトを作ることで解決できないか？
  3. 既存のドメインオブジェクトのメソッドとして実装できないか？
- まずドメインオブジェクト内での実装を試み、それが本当に不自然な場合のみドメインサービスを検討する

---

## テスト駆動開発 (TDD)

- Red-Green-Refactor サイクルを必ず踏む
- テストを仕様として扱い、失敗するテストを起点に設計を前進させる
- 小さな単位で反復して、リファクタリングを継続的に行う
- 詳細なワークフローはプロジェクトや技術スタックごとに定義する

---

## 実装パターン

### アダプターパターン

- 外部依存を抽象化する
- インターフェースは呼び出し側で定義する
- テスト時は容易に差し替え可能にする

---

## 実装手順

1. **型設計**
   - まず型を定義する
   - ドメインの言語を型で表現する
2. **純粋関数から実装**
   - 外部依存のない関数から実装を開始する
   - テストを先に書く
3. **副作用を分離**
   - I/O 操作は関数の境界に押し出す
   - 副作用を持つ処理は明示的に境界へ分離し、必要なら非同期制御（Promise など）で扱う
   - 実装後は可能な限り linter や静的解析ツールを実行し、早期に不整合を検出する
4. **アダプター実装**
   - 外部サービスやデータベースへのアクセスを抽象化する
   - テスト用モックを用意する

---

## プラクティス

- 小さく始めて段階的に拡張する
- 過度な抽象化を避ける
- コードよりも型を重視する
- 複雑さに応じてアプローチを調整する

---

## コードスタイル

- 不変更新パターンを活用する
- 早期リターンで条件分岐をフラット化する
- エラーとユースケースを列挙型で定義する

---

## テスト戦略

- 純粋関数の単体テストを優先する
- インメモリ実装によるリポジトリテストを用意する
- テスト可能性を設計に組み込む
- アサートファーストの姿勢で期待結果から逆算する

---

## ドキュメント

- Props など interface には、可能な限り以下のコメントを記載する、コメントを記載した場合は実装ファイルは最小限にする
  - Props の説明
  - メンバーの意味
- 各種ドキュメントに実装例は最低限の記載にする
